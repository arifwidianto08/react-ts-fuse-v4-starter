{"contents":"'use strict';\n(function () {\n  'use strict';\n  var DEFAULT_THREAD_ID = 0;\n  var interactionIDCounter = 0;\n  var threadIDCounter = 0;\n  exports.__interactionsRef = null;\n  exports.__subscriberRef = null;\n  {\n    exports.__interactionsRef = {\n      current: new Set()\n    };\n    exports.__subscriberRef = {\n      current: null\n    };\n  }\n  function unstable_clear(callback) {\n    var prevInteractions = exports.__interactionsRef.current;\n    exports.__interactionsRef.current = new Set();\n    try {\n      return callback();\n    } finally {\n      exports.__interactionsRef.current = prevInteractions;\n    }\n  }\n  function unstable_getCurrent() {\n    {\n      return exports.__interactionsRef.current;\n    }\n  }\n  function unstable_getThreadID() {\n    return ++threadIDCounter;\n  }\n  function unstable_trace(name, timestamp, callback) {\n    var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\n    var interaction = {\n      __count: 1,\n      id: interactionIDCounter++,\n      name: name,\n      timestamp: timestamp\n    };\n    var prevInteractions = exports.__interactionsRef.current;\n    var interactions = new Set(prevInteractions);\n    interactions.add(interaction);\n    exports.__interactionsRef.current = interactions;\n    var subscriber = exports.__subscriberRef.current;\n    var returnValue;\n    try {\n      if (subscriber !== null) {\n        subscriber.onInteractionTraced(interaction);\n      }\n    } finally {\n      try {\n        if (subscriber !== null) {\n          subscriber.onWorkStarted(interactions, threadID);\n        }\n      } finally {\n        try {\n          returnValue = callback();\n        } finally {\n          exports.__interactionsRef.current = prevInteractions;\n          try {\n            if (subscriber !== null) {\n              subscriber.onWorkStopped(interactions, threadID);\n            }\n          } finally {\n            interaction.__count--;\n            if (subscriber !== null && interaction.__count === 0) {\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\n            }\n          }\n        }\n      }\n    }\n    return returnValue;\n  }\n  function unstable_wrap(callback) {\n    var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\n    var wrappedInteractions = exports.__interactionsRef.current;\n    var subscriber = exports.__subscriberRef.current;\n    if (subscriber !== null) {\n      subscriber.onWorkScheduled(wrappedInteractions, threadID);\n    }\n    wrappedInteractions.forEach(function (interaction) {\n      interaction.__count++;\n    });\n    var hasRun = false;\n    function wrapped() {\n      var prevInteractions = exports.__interactionsRef.current;\n      exports.__interactionsRef.current = wrappedInteractions;\n      subscriber = exports.__subscriberRef.current;\n      try {\n        var returnValue;\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkStarted(wrappedInteractions, threadID);\n          }\n        } finally {\n          try {\n            returnValue = callback.apply(undefined, arguments);\n          } finally {\n            exports.__interactionsRef.current = prevInteractions;\n            if (subscriber !== null) {\n              subscriber.onWorkStopped(wrappedInteractions, threadID);\n            }\n          }\n        }\n        return returnValue;\n      } finally {\n        if (!hasRun) {\n          hasRun = true;\n          wrappedInteractions.forEach(function (interaction) {\n            interaction.__count--;\n            if (subscriber !== null && interaction.__count === 0) {\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\n            }\n          });\n        }\n      }\n    }\n    wrapped.cancel = function cancel() {\n      subscriber = exports.__subscriberRef.current;\n      try {\n        if (subscriber !== null) {\n          subscriber.onWorkCanceled(wrappedInteractions, threadID);\n        }\n      } finally {\n        wrappedInteractions.forEach(function (interaction) {\n          interaction.__count--;\n          if (subscriber && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        });\n      }\n    };\n    return wrapped;\n  }\n  var subscribers = null;\n  {\n    subscribers = new Set();\n  }\n  function unstable_subscribe(subscriber) {\n    {\n      subscribers.add(subscriber);\n      if (subscribers.size === 1) {\n        exports.__subscriberRef.current = {\n          onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\n          onInteractionTraced: onInteractionTraced,\n          onWorkCanceled: onWorkCanceled,\n          onWorkScheduled: onWorkScheduled,\n          onWorkStarted: onWorkStarted,\n          onWorkStopped: onWorkStopped\n        };\n      }\n    }\n  }\n  function unstable_unsubscribe(subscriber) {\n    {\n      subscribers.delete(subscriber);\n      if (subscribers.size === 0) {\n        exports.__subscriberRef.current = null;\n      }\n    }\n  }\n  function onInteractionTraced(interaction) {\n    var didCatchError = false;\n    var caughtError = null;\n    subscribers.forEach(function (subscriber) {\n      try {\n        subscriber.onInteractionTraced(interaction);\n      } catch (error) {\n        if (!didCatchError) {\n          didCatchError = true;\n          caughtError = error;\n        }\n      }\n    });\n    if (didCatchError) {\n      throw caughtError;\n    }\n  }\n  function onInteractionScheduledWorkCompleted(interaction) {\n    var didCatchError = false;\n    var caughtError = null;\n    subscribers.forEach(function (subscriber) {\n      try {\n        subscriber.onInteractionScheduledWorkCompleted(interaction);\n      } catch (error) {\n        if (!didCatchError) {\n          didCatchError = true;\n          caughtError = error;\n        }\n      }\n    });\n    if (didCatchError) {\n      throw caughtError;\n    }\n  }\n  function onWorkScheduled(interactions, threadID) {\n    var didCatchError = false;\n    var caughtError = null;\n    subscribers.forEach(function (subscriber) {\n      try {\n        subscriber.onWorkScheduled(interactions, threadID);\n      } catch (error) {\n        if (!didCatchError) {\n          didCatchError = true;\n          caughtError = error;\n        }\n      }\n    });\n    if (didCatchError) {\n      throw caughtError;\n    }\n  }\n  function onWorkStarted(interactions, threadID) {\n    var didCatchError = false;\n    var caughtError = null;\n    subscribers.forEach(function (subscriber) {\n      try {\n        subscriber.onWorkStarted(interactions, threadID);\n      } catch (error) {\n        if (!didCatchError) {\n          didCatchError = true;\n          caughtError = error;\n        }\n      }\n    });\n    if (didCatchError) {\n      throw caughtError;\n    }\n  }\n  function onWorkStopped(interactions, threadID) {\n    var didCatchError = false;\n    var caughtError = null;\n    subscribers.forEach(function (subscriber) {\n      try {\n        subscriber.onWorkStopped(interactions, threadID);\n      } catch (error) {\n        if (!didCatchError) {\n          didCatchError = true;\n          caughtError = error;\n        }\n      }\n    });\n    if (didCatchError) {\n      throw caughtError;\n    }\n  }\n  function onWorkCanceled(interactions, threadID) {\n    var didCatchError = false;\n    var caughtError = null;\n    subscribers.forEach(function (subscriber) {\n      try {\n        subscriber.onWorkCanceled(interactions, threadID);\n      } catch (error) {\n        if (!didCatchError) {\n          didCatchError = true;\n          caughtError = error;\n        }\n      }\n    });\n    if (didCatchError) {\n      throw caughtError;\n    }\n  }\n  exports.unstable_clear = unstable_clear;\n  exports.unstable_getCurrent = unstable_getCurrent;\n  exports.unstable_getThreadID = unstable_getThreadID;\n  exports.unstable_subscribe = unstable_subscribe;\n  exports.unstable_trace = unstable_trace;\n  exports.unstable_unsubscribe = unstable_unsubscribe;\n  exports.unstable_wrap = unstable_wrap;\n})();\n"}